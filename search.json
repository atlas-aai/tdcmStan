[{"path":[]},{"path":"/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official email address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement jeffrey.c.hoover@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to tdcmStan","title":"Contributing to tdcmStan","text":"outlines propose change tdcmStan.","code":""},{"path":"/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to tdcmStan","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to tdcmStan","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed). See tidyverse guide create great issue advice.","code":""},{"path":"/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to tdcmStan","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"atlas-aai/tdcmStan\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to tdcmStan","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to tdcmStan","text":"Please note tdcmStan project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":[]},{"path":"/articles/tdcmStan.html","id":"tdcmstan","dir":"Articles","previous_headings":"Installation","what":"tdcmStan","title":"Using tdcmStan","text":"can install release version tdcmStan CRAN: install development version GitHub use:","code":"install.packages(\"tdcmStan\") # install.packages(\"remotes\") remotes::install_github(\"atlas-aai/tdcmStan\")"},{"path":"/articles/tdcmStan.html","id":"rstan-and-cmdstanr","dir":"Articles","previous_headings":"Installation","what":"rstan and cmdstanr","title":"Using tdcmStan","text":"estimate models using Stan code, users need installation rstan cmdstanr. instructions installing rstan can found : RStan Getting Started Windows, Mac, Linux. instructions installing cmdstanr can found : Getting Started CmdStanR. full demonstration install use rstan cmdstanr outside scope vignette.","code":""},{"path":"/articles/tdcmStan.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"Using tdcmStan","text":"tdcmStan installed, ready create Stan code estimating TDCM.","code":"library(tdcmStan)"},{"path":"/articles/tdcmStan.html","id":"tdcm","dir":"Articles","previous_headings":"Usage","what":"TDCM","title":"Using tdcmStan","text":"demonstrate workflow using tdcmStan, present example case generating Stan code. example, assume going estimating TDCM 5-item 1-attribute assessment administered two time points. example, resulting Stan code first saved stan_code object, Stan code saved .stan file can read model estimation. consistent assumption item invariance described -Madison & Bradshaw (2018), create_stan_tdcm() function estimates item parameters parameter values item Time 1 Time 2.","code":"library(tibble) library(here) library(readr)  q_matrix <- tibble(rep(1, 5)) stan_code <- create_stan_tdcm(q_matrix) stan_code %>%   readr::write_lines(here(\"Stan/tdcm.stan\"))"},{"path":"/articles/tdcmStan.html","id":"multi-threaded-tdcm","dir":"Articles","previous_headings":"Usage","what":"Multi-Threaded TDCM","title":"Using tdcmStan","text":"many cases, process estimating Bayesian TDCMs may time intensive. work around , can use estimate TDCM multi-threading, uses parallel processes increase estimation efficiency reduce estimation time. estimate TDCM multi-threading, run:","code":"fng_stan_code <- create_threaded_stan_tdcm(q_matrix)"},{"path":"/articles/tdcmStan.html","id":"calculating-the-number-of-shards","dir":"Articles","previous_headings":"Usage","what":"Calculating the Number of Shards","title":"Using tdcmStan","text":"number shards refers number parallel processes used multi-threaded TDCM. tdcmStan package includes shard_calculator() function automatically calculate many shards can used. , run:","code":"num_respondents <- 100 num_responses <- 500 num_chains <- 4 shard_calculator(num_respondents, num_responses, num_chains)"},{"path":"/articles/tdcmStan.html","id":"fungible-tdcm","dir":"Articles","previous_headings":"Usage","what":"Fungible TDCM","title":"Using tdcmStan","text":"tdcmStan package follows similar process producing Stan code TDCMs constraints. addition assumption item invariance across time points, can assume item fungibility. Fungibility means items measuring attribute assumed item parameter values. example, running example, five items measure attribute. fungible model, means one shared item intercept parameter one shared item main effect parameter five items. estimate fungible TDCM 5-item 1-attribute assessment, run:","code":"fng_stan_code <- create_fng_stan_tdcm(q_matrix)"},{"path":"/articles/tdcmStan.html","id":"fungible-tdcm-with-no-common-items","dir":"Articles","previous_headings":"Usage","what":"Fungible TDCM with No Common Items","title":"Using tdcmStan","text":"previous examples created Stan code estimating TDCM assumption respondents completing items assessment point; however, may always case assessment programs. assessment programs may allow respondents complete item . estimate fungible TDCM 1-attribute assessment respondents complete different items assessment point, run: example, assessment consists five items completed time point, respondents complete item twice. means respondents completing five items Time 1 five items Time 2, items completed Time 1 necessarily consistent across respondents. example, Respondent 1 might complete Items 2, 4, 6, 8, 10 Time 1 remaining items Time 2, Respondent 2 might complete Items 1, 2, 3, 4, 5 Time 1 remaining items Time 2.","code":"q_matrix <- tibble(rep(1, 10)) fng_no_cmn_items_stan_code <- create_fng_no_common_item_tdcm(q_matrix)"},{"path":[]},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jeffrey Hoover. Author, maintainer. W. Jake Thompson. Author. University Kansas. Copyright holder.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hoover J, Thompson W (2024). tdcmStan: Automating Creation Stan Code TDCMs. R package version 3.0.0.9000, https://github.com/atlas-aai/tdcmStan.","code":"@Manual{,   title = {tdcmStan: Automating the Creation of Stan Code for TDCMs},   author = {Jeffrey Hoover and W. Jake Thompson},   year = {2024},   note = {R package version 3.0.0.9000},   url = {https://github.com/atlas-aai/tdcmStan}, }"},{"path":"/index.html","id":"tdcmstan","dir":"","previous_headings":"","what":"Automating the Creation of Stan Code for TDCMs","title":"Automating the Creation of Stan Code for TDCMs","text":"goal tdcmStan facilitate production Stan code estimating transition diagnostic classification models (TDCMs). TDCMs psychometric models estimate respondents latent class membership longitudinally. Using R, tdcmStan uses Q-matrix automatically produce Stan code. tdcmStan package supports unconstrained TDCMs along fungible TDCMs (.e., TDCMs items parameters assumed equivalent) fungible TDCMs common items across time points. tdcmStan package also supports estimation multi-threaded TDCMs, increases efficiency model estimation.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Automating the Creation of Stan Code for TDCMs","text":"can install release version tdcmStan CRAN: install development version GitHub use:","code":"install.packages(\"tdcmStan\") # install.packages(\"remotes\") remotes::install_github(\"atlas-aai/tdcmStan\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Automating the Creation of Stan Code for TDCMs","text":"demonstrate workflow using tdcmStan, present example case generating Stan code. example, assume going estimating TDCM 5-item 1-attribute assessment administered two time points. produced stan code first saved stan_code, Stan code saved Stan file Stan/tdcm.stan can read model estimation. tdcmStan package follows similar process variants TDCMs. estimate multi-threaded TDCM 5-item 1-attribute assessment, run: estimate fungible TDCM 5-item 1-attribute assessment, run: estimate fungible TDCM 1-attribute assessment respondents complete 5 items time point respondents complete item twice, run: Contributions welcome. ensure smooth process, please review Contributing Guide. Please note dcm2 project released Contributor Code Conduct. contributing project, agree abide terms.","code":"library(tibble) library(here) library(readr) library(tdcmStan)  q_matrix <- tibble(rep(1, 5)) stan_code <- create_stan_tdcm(q_matrix) stan_code %>%     readr::write_lines(here(\"Stan/tdcm.stan\")) fng_stan_code <- create_threaded_stan_tdcm(q_matrix) fng_stan_code <- create_fng_stan_tdcm(q_matrix) q_matrix <- tibble(rep(1, 10)) fng_no_cmn_items_stan_code <- create_fng_no_common_item_tdcm(q_matrix)"},{"path":"/reference/bin_profile.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating a Class by Attribute Matrix — bin_profile","title":"Creating a Class by Attribute Matrix — bin_profile","text":"Automating creation Class Attribute Matrix","code":""},{"path":"/reference/bin_profile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating a Class by Attribute Matrix — bin_profile","text":"","code":"bin_profile(natt)"},{"path":"/reference/bin_profile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating a Class by Attribute Matrix — bin_profile","text":"natt integer containing number assessed attributes.","code":""},{"path":"/reference/bin_profile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating a Class by Attribute Matrix — bin_profile","text":"`profiles` tibble containing class attribute matrix listing attributes mastered latent class.","code":""},{"path":"/reference/bin_profile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating a Class by Attribute Matrix — bin_profile","text":"","code":"bin_profile(natt = 3) #> # A tibble: 8 × 3 #>   att_1 att_2 att_3 #>   <int> <int> <int> #> 1     0     0     0 #> 2     1     0     0 #> 3     0     1     0 #> 4     0     0     1 #> 5     1     1     0 #> 6     1     0     1 #> 7     0     1     1 #> 8     1     1     1"},{"path":"/reference/create_fng_no_common_item_tdcm.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating Fungible TDCM with No Common Items Stan Code — create_fng_no_common_item_tdcm","title":"Creating Fungible TDCM with No Common Items Stan Code — create_fng_no_common_item_tdcm","text":"Automating creation fungible Stan code TDCM common items.","code":""},{"path":"/reference/create_fng_no_common_item_tdcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating Fungible TDCM with No Common Items Stan Code — create_fng_no_common_item_tdcm","text":"","code":"create_fng_no_common_item_tdcm(q_matrix)"},{"path":"/reference/create_fng_no_common_item_tdcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating Fungible TDCM with No Common Items Stan Code — create_fng_no_common_item_tdcm","text":"q_matrix tibble containing assessment Q-matrix.","code":""},{"path":"/reference/create_fng_no_common_item_tdcm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating Fungible TDCM with No Common Items Stan Code — create_fng_no_common_item_tdcm","text":"`stan_code` list containing text Stan code blocks.","code":""},{"path":"/reference/create_fng_no_common_item_tdcm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating Fungible TDCM with No Common Items Stan Code — create_fng_no_common_item_tdcm","text":"","code":"qmatrix = tibble::tibble(att_1 = c(1, 0, 1, 0, 1, 0),                          att_2 = c(0, 1, 0, 1, 0, 1)) create_fng_no_common_item_tdcm(q_matrix = qmatrix) #> $data #> data { #>   int<lower=1> I; #>   int<lower=1> J; #>   int<lower=1> N; #>   int<lower=1> C; #>   int<lower=1> A; #>   array[N, 2] int<lower=1,upper=I> ii; #>   array[N, 2] int<lower=0> y; #>   array[J, 2] int<lower=1,upper=N> s; #>   array[J, 2] int<lower=1,upper=I> l; #>   matrix[C,A] Alpha; #> } #>  #> $parameters #> parameters { #>   array[C] simplex[C] tau; #>   simplex[C] Vc; #>   real l_0; #>   real<lower=0> l_1; #> } #>  #> $transformed_parameters #> transformed parameters { #>   matrix[I,C] pi; #>  #>   pi[1,1] = inv_logit(l_0); #>   pi[2,1] = inv_logit(l_0); #>   pi[3,1] = inv_logit(l_0); #>   pi[4,1] = inv_logit(l_0); #>   pi[5,1] = inv_logit(l_0); #>   pi[6,1] = inv_logit(l_0); #>   pi[1,2] = inv_logit(l_0+l_1); #>   pi[2,2] = inv_logit(l_0); #>   pi[3,2] = inv_logit(l_0+l_1); #>   pi[4,2] = inv_logit(l_0); #>   pi[5,2] = inv_logit(l_0+l_1); #>   pi[6,2] = inv_logit(l_0); #>   pi[1,3] = inv_logit(l_0); #>   pi[2,3] = inv_logit(l_0+l_1); #>   pi[3,3] = inv_logit(l_0); #>   pi[4,3] = inv_logit(l_0+l_1); #>   pi[5,3] = inv_logit(l_0); #>   pi[6,3] = inv_logit(l_0+l_1); #>   pi[1,4] = inv_logit(l_0+l_1); #>   pi[2,4] = inv_logit(l_0+l_1); #>   pi[3,4] = inv_logit(l_0+l_1); #>   pi[4,4] = inv_logit(l_0+l_1); #>   pi[5,4] = inv_logit(l_0+l_1); #>   pi[6,4] = inv_logit(l_0+l_1); #> } #>  #> $model #> model { #>   array[C, C] real ps; #>  #>   // Priors #>   l_0 ~ normal(0, 2); #>   l_1 ~ lognormal(0, 1); #>  #>   // Likelihood #>   for (j in 1:J) { #>     vector[C] tmp; #>     for (c1 in 1:C) { #>       for (c2 in 1:C) { #>         array[l[j, 1]] real log_items; #>         for (m in 1:l[j, 1]) { #>           int i = ii[s[j, 1] + m - 1, 1]; #>           real tmp1 = 0; #>           real tmp2 = 0; #>           if(y[s[j, 1] + m - 1, 1] != 9) {tmp1 = y[s[j, 1] + m - 1, 1] * log(pi[i,c1]) + (1 - y[s[j, 1] + m - 1, 1]) * log(1 - pi[i,c1]);} #>           if(y[s[j, 1] + m - 1, 2] != 9) {tmp2 = y[s[j, 1] + m - 1, 2] * log(pi[i,c2]) + (1 - y[s[j, 1] + m - 1, 2]) * log(1 - pi[i,c2]);} #>           log_items[m] = tmp1 + tmp2; #>         } #>         ps[c1, c2] = log(Vc[c1]) + log(tau[c1, c2]) + sum(log_items); #>       } #>       tmp[c1] = log_sum_exp(ps[c1,]); #>     } #>     target += log_sum_exp(tmp); #>   } #> } #>  #> $generated_quantities #> generated quantities { #>   vector[J] log_lik; #>   array[J] matrix[C, C] prob_transition_class; #>   array[J] matrix[A, 2] prob_resp_attr; #>  #>   // Likelihood #>   for (j in 1:J) { #>     vector[C] tmp; #>     array[C, C] real ps; #>     for (c1 in 1:C) { #>       for (c2 in 1:C) { #>         array[l[j, 1]] real log_items; #>         for (m in 1:l[j, 1]) { #>           int i = ii[s[j, 1] + m - 1, 1]; #>           real tmp1 = 0; #>           real tmp2 = 0; #>           if(y[s[j, 1] + m - 1, 1] != 9) {tmp1 = y[s[j, 1] + m - 1, 1] * log(pi[i,c1]) + (1 - y[s[j, 1] + m - 1, 1]) * log(1 - pi[i,c1]);} #>           if(y[s[j, 1] + m - 1, 2] != 9) {tmp2 = y[s[j, 1] + m - 1, 2] * log(pi[i,c2]) + (1 - y[s[j, 1] + m - 1, 2]) * log(1 - pi[i,c2]);} #>           log_items[m] = tmp1 + tmp2; #>         } #>         ps[c1, c2] = log(Vc[c1]) + log(tau[c1, c2]) + sum(log_items); #>       } #>       tmp[c1] = log_sum_exp(ps[c1,]); #>     } #>     log_lik[j] = log_sum_exp(tmp); #>   } #>  #>   // latent class probabilities #>   for (j in 1:J) { #>     vector[C] tmp; #>     matrix[C, C] prob_joint; #>     for (c1 in 1:C) { #>       for (c2 in 1:C) { #>         array[l[j, 1]] real log_items; #>         for (m in 1:l[j, 1]) { #>           int i = ii[s[j, 1] + m - 1, 1]; #>           real tmp1 = 0; #>           real tmp2 = 0; #>           if(y[s[j, 1] + m - 1, 1] != 9) {tmp1 = y[s[j, 1] + m - 1, 1] * log(pi[i,c1]) + (1 - y[s[j, 1] + m - 1, 1]) * log(1 - pi[i,c1]);} #>           if(y[s[j, 1] + m - 1, 2] != 9) {tmp2 = y[s[j, 1] + m - 1, 2] * log(pi[i,c2]) + (1 - y[s[j, 1] + m - 1, 2]) * log(1 - pi[i,c2]);} #>           log_items[m] = tmp1 + tmp2; #>         } #>         prob_joint[c1, c2] = log(Vc[c1]) + log(tau[c1, c2]) + sum(log_items); #>       } #>     } #>     prob_transition_class[j] = exp(prob_joint) / sum(exp(prob_joint)); #>   } #>  #>   for (j in 1:J) { #>     for (a in 1:A) { #>       vector[C] prob_attr_class_t1; #>       vector[C] prob_attr_class_t2; #>       for (c in 1:C) { #>         prob_attr_class_t1[c] = sum(prob_transition_class[j,c,]) * Alpha[c,a]; #>         prob_attr_class_t2[c] = sum(prob_transition_class[j,,c]) * Alpha[c,a]; #>       } #>       prob_resp_attr[j,a,1] = sum(prob_attr_class_t1); #>       prob_resp_attr[j,a,2] = sum(prob_attr_class_t2); #>     } #>   } #> } #>"},{"path":"/reference/create_fng_stan_tdcm.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating Fungible TDCM Stan Code — create_fng_stan_tdcm","title":"Creating Fungible TDCM Stan Code — create_fng_stan_tdcm","text":"Automating creation fungible Stan code TDCM.","code":""},{"path":"/reference/create_fng_stan_tdcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating Fungible TDCM Stan Code — create_fng_stan_tdcm","text":"","code":"create_fng_stan_tdcm(q_matrix)"},{"path":"/reference/create_fng_stan_tdcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating Fungible TDCM Stan Code — create_fng_stan_tdcm","text":"q_matrix tibble containing assessment Q-matrix.","code":""},{"path":"/reference/create_fng_stan_tdcm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating Fungible TDCM Stan Code — create_fng_stan_tdcm","text":"`stan_code` list containing text Stan code blocks.","code":""},{"path":"/reference/create_fng_stan_tdcm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating Fungible TDCM Stan Code — create_fng_stan_tdcm","text":"","code":"qmatrix = tibble::tibble(att_1 = c(1, 0, 1, 0, 1, 0),                          att_2 = c(0, 1, 0, 1, 0, 1)) create_fng_stan_tdcm(q_matrix = qmatrix) #> $data #> data { #>   int<lower=1> I; #>   int<lower=1> J; #>   int<lower=1> N; #>   int<lower=1> C; #>   int<lower=1> A; #>   array[N, 2] int<lower=1,upper=I> ii; #>   array[N, 2] int<lower=0,upper=1> y; #>   array[J, 2] int<lower=1,upper=N> s; #>   array[J, 2] int<lower=1,upper=I> l; #>   matrix[C,A] Alpha; #> } #>  #> $parameters #> parameters { #>   array[C] simplex[C] tau; #>   simplex[C] Vc; #>   real l_0; #>   real<lower=0> l_1; #> } #>  #> $transformed_parameters #> transformed parameters { #>   matrix[I,C] pi; #>  #>   pi[1,1] = inv_logit(l_0); #>   pi[2,1] = inv_logit(l_0); #>   pi[3,1] = inv_logit(l_0); #>   pi[4,1] = inv_logit(l_0); #>   pi[5,1] = inv_logit(l_0); #>   pi[6,1] = inv_logit(l_0); #>   pi[1,2] = inv_logit(l_0+l_1); #>   pi[2,2] = inv_logit(l_0); #>   pi[3,2] = inv_logit(l_0+l_1); #>   pi[4,2] = inv_logit(l_0); #>   pi[5,2] = inv_logit(l_0+l_1); #>   pi[6,2] = inv_logit(l_0); #>   pi[1,3] = inv_logit(l_0); #>   pi[2,3] = inv_logit(l_0+l_1); #>   pi[3,3] = inv_logit(l_0); #>   pi[4,3] = inv_logit(l_0+l_1); #>   pi[5,3] = inv_logit(l_0); #>   pi[6,3] = inv_logit(l_0+l_1); #>   pi[1,4] = inv_logit(l_0+l_1); #>   pi[2,4] = inv_logit(l_0+l_1); #>   pi[3,4] = inv_logit(l_0+l_1); #>   pi[4,4] = inv_logit(l_0+l_1); #>   pi[5,4] = inv_logit(l_0+l_1); #>   pi[6,4] = inv_logit(l_0+l_1); #> } #>  #> $model #> model { #>   array[C, C] real ps; #>  #>   // Priors #>   l_0 ~ normal(0, 2); #>   l_1 ~ lognormal(0, 1); #>  #>   // Likelihood #>   for (j in 1:J) { #>     vector[C] tmp; #>     for (c1 in 1:C) { #>       for (c2 in 1:C) { #>         array[l[j, 1]] real log_items; #>         for (m in 1:l[j, 1]) { #>           int i = ii[s[j, 1] + m - 1, 1]; #>           log_items[m] = y[s[j, 1] + m - 1, 1] * log(pi[i,c1]) + (1 - y[s[j, 1] + m - 1, 1]) * log(1 - pi[i,c1]) + y[s[j, 1] + m - 1, 2] * log(pi[i,c2]) + (1 - y[s[j, 1] + m - 1, 2]) * log(1 - pi[i,c2]); #>         } #>         ps[c1, c2] = log(Vc[c1]) + log(tau[c1, c2]) + sum(log_items); #>       } #>       tmp[c1] = log_sum_exp(ps[c1,]); #>     } #>     target += log_sum_exp(tmp); #>   } #> } #>  #> $generated_quantities #> generated quantities { #>   vector[J] log_lik; #>   array[J] matrix[C, C] prob_transition_class; #>   array[J] matrix[A, 2] prob_resp_attr; #>  #>   // Likelihood #>   for (j in 1:J) { #>     vector[C] tmp; #>     array[C, C] real ps; #>     for (c1 in 1:C) { #>       for (c2 in 1:C) { #>         array[l[j, 1]] real log_items; #>         for (m in 1:l[j, 1]) { #>           int i = ii[s[j, 1] + m - 1, 1]; #>           log_items[m] = y[s[j, 1] + m - 1, 1] * log(pi[i,c1]) + (1 - y[s[j, 1] + m - 1, 1]) * log(1 - pi[i,c1]) + y[s[j, 1] + m - 1, 2] * log(pi[i,c2]) + (1 - y[s[j, 1] + m - 1, 2]) * log(1 - pi[i,c2]); #>         } #>         ps[c1, c2] = log(Vc[c1]) + log(tau[c1, c2]) + sum(log_items); #>       } #>       tmp[c1] = log_sum_exp(ps[c1,]); #>     } #>     log_lik[j] = log_sum_exp(tmp); #>   } #>  #>   // latent class probabilities #>   for (j in 1:J) { #>     vector[C] tmp; #>     matrix[C, C] prob_joint; #>     for (c1 in 1:C) { #>       for (c2 in 1:C) { #>         array[l[j, 1]] real log_items; #>         for (m in 1:l[j, 1]) { #>           int i = ii[s[j, 1] + m - 1, 1]; #>           log_items[m] = y[s[j, 1] + m - 1, 1] * log(pi[i,c1]) + (1 - y[s[j, 1] + m - 1, 1]) * log(1 - pi[i,c1]) + y[s[j, 1] + m - 1, 2] * log(pi[i,c2]) + (1 - y[s[j, 1] + m - 1, 2]) * log(1 - pi[i,c2]); #>         } #>         prob_joint[c1, c2] = log(Vc[c1]) + log(tau[c1, c2]) + sum(log_items); #>       } #>     } #>     prob_transition_class[j] = exp(prob_joint) / sum(exp(prob_joint)); #>   } #>  #>   for (j in 1:J) { #>     for (a in 1:A) { #>       vector[C] prob_attr_class_t1; #>       vector[C] prob_attr_class_t2; #>       for (c in 1:C) { #>         prob_attr_class_t1[c] = sum(prob_transition_class[j,c,]) * Alpha[c,a]; #>         prob_attr_class_t2[c] = sum(prob_transition_class[j,,c]) * Alpha[c,a]; #>       } #>       prob_resp_attr[j,a,1] = sum(prob_attr_class_t1); #>       prob_resp_attr[j,a,2] = sum(prob_attr_class_t2); #>     } #>   } #> } #>"},{"path":"/reference/create_stan_tdcm.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating TDCM Stan Code — create_stan_tdcm","title":"Creating TDCM Stan Code — create_stan_tdcm","text":"Automating creation Stan code TDCM.","code":""},{"path":"/reference/create_stan_tdcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating TDCM Stan Code — create_stan_tdcm","text":"","code":"create_stan_tdcm(q_matrix)"},{"path":"/reference/create_stan_tdcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating TDCM Stan Code — create_stan_tdcm","text":"q_matrix tibble containing assessment Q-matrix.","code":""},{"path":"/reference/create_stan_tdcm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating TDCM Stan Code — create_stan_tdcm","text":"`stan_code` list containing text Stan code blocks.","code":""},{"path":"/reference/create_stan_tdcm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating TDCM Stan Code — create_stan_tdcm","text":"","code":"qmatrix = tibble::tibble(att_1 = c(1, 0, 1, 0, 1, 1),                          att_2 = c(0, 1, 0, 1, 1, 1)) create_stan_tdcm(q_matrix = qmatrix) #> $data #> data { #>   int<lower=1> I; #>   int<lower=1> J; #>   int<lower=1> N; #>   int<lower=1> C; #>   int<lower=1> A; #>   array[N, 2] int<lower=1,upper=I> ii; #>   array[N, 2] int<lower=0,upper=1> y; #>   array[J, 2] int<lower=1,upper=N> s; #>   array[J, 2] int<lower=1,upper=I> l; #>   matrix[C,A] Alpha; #> } #>  #> $parameters #> parameters { #>   array[C] simplex[C] tau; #>   simplex[C] Vc; #>   real l1_0; #>   real l2_0; #>   real l3_0; #>   real l4_0; #>   real l5_0; #>   real l6_0; #>   real<lower=0> l1_11; #>   real<lower=0> l2_12; #>   real<lower=0> l3_11; #>   real<lower=0> l4_12; #>   real<lower=0> l5_11; #>   real<lower=0> l5_12; #>   real<lower=0> l6_11; #>   real<lower=0> l6_12; #>   real<lower=-1 * fmin(l5_11, l5_12)> l5_212; #>   real<lower=-1 * fmin(l6_11, l6_12)> l6_212; #> } #>  #> $transformed_parameters #> transformed parameters { #>   matrix[I,C] pi; #>  #>   pi[1,1] = inv_logit(l1_0); #>   pi[2,1] = inv_logit(l2_0); #>   pi[3,1] = inv_logit(l3_0); #>   pi[4,1] = inv_logit(l4_0); #>   pi[5,1] = inv_logit(l5_0); #>   pi[6,1] = inv_logit(l6_0); #>   pi[1,2] = inv_logit(l1_0+l1_11); #>   pi[2,2] = inv_logit(l2_0); #>   pi[3,2] = inv_logit(l3_0+l3_11); #>   pi[4,2] = inv_logit(l4_0); #>   pi[5,2] = inv_logit(l5_0+l5_11); #>   pi[6,2] = inv_logit(l6_0+l6_11); #>   pi[1,3] = inv_logit(l1_0); #>   pi[2,3] = inv_logit(l2_0+l2_12); #>   pi[3,3] = inv_logit(l3_0); #>   pi[4,3] = inv_logit(l4_0+l4_12); #>   pi[5,3] = inv_logit(l5_0+l5_12); #>   pi[6,3] = inv_logit(l6_0+l6_12); #>   pi[1,4] = inv_logit(l1_0+l1_11); #>   pi[2,4] = inv_logit(l2_0+l2_12); #>   pi[3,4] = inv_logit(l3_0+l3_11); #>   pi[4,4] = inv_logit(l4_0+l4_12); #>   pi[5,4] = inv_logit(l5_0+l5_11+l5_12+l5_212); #>   pi[6,4] = inv_logit(l6_0+l6_11+l6_12+l6_212); #> } #>  #> $model #> model { #>   array[C, C] real ps; #>  #>   // Priors #>   l1_0 ~ normal(0, 2); #>   l2_0 ~ normal(0, 2); #>   l3_0 ~ normal(0, 2); #>   l4_0 ~ normal(0, 2); #>   l5_0 ~ normal(0, 2); #>   l6_0 ~ normal(0, 2); #>   l1_11 ~ lognormal(0, 1); #>   l2_12 ~ lognormal(0, 1); #>   l3_11 ~ lognormal(0, 1); #>   l4_12 ~ lognormal(0, 1); #>   l5_11 ~ lognormal(0, 1); #>   l5_12 ~ lognormal(0, 1); #>   l6_11 ~ lognormal(0, 1); #>   l6_12 ~ lognormal(0, 1); #>   l5_212 ~ normal(0, 2); #>   l6_212 ~ normal(0, 2); #>  #>   // Likelihood #>   for (j in 1:J) { #>     vector[C] tmp; #>     for (c1 in 1:C) { #>       for (c2 in 1:C) { #>         array[l[j, 1]] real log_items; #>         for (m in 1:l[j, 1]) { #>           int i = ii[s[j, 1] + m - 1, 1]; #>           log_items[m] = y[s[j, 1] + m - 1, 1] * log(pi[i,c1]) + (1 - y[s[j, 1] + m - 1, 1]) * log(1 - pi[i,c1]) + y[s[j, 1] + m - 1, 2] * log(pi[i,c2]) + (1 - y[s[j, 1] + m - 1, 2]) * log(1 - pi[i,c2]); #>         } #>         ps[c1, c2] = log(Vc[c1]) + log(tau[c1, c2]) + sum(log_items); #>       } #>       tmp[c1] = log_sum_exp(ps[c1,]); #>     } #>     target += log_sum_exp(tmp); #>   } #> } #>  #> $generated_quantities #> generated quantities { #>   vector[J] log_lik; #>   array[J] matrix[C, C] prob_transition_class; #>   array[J] matrix[A, 2] prob_resp_attr; #>  #>   // Likelihood #>   for (j in 1:J) { #>     vector[C] tmp; #>     array[C, C] real ps; #>     for (c1 in 1:C) { #>       for (c2 in 1:C) { #>         array[l[j, 1]] real log_items; #>         for (m in 1:l[j, 1]) { #>           int i = ii[s[j, 1] + m - 1, 1]; #>           log_items[m] = y[s[j, 1] + m - 1, 1] * log(pi[i,c1]) + (1 - y[s[j, 1] + m - 1, 1]) * log(1 - pi[i,c1]) + y[s[j, 1] + m - 1, 2] * log(pi[i,c2]) + (1 - y[s[j, 1] + m - 1, 2]) * log(1 - pi[i,c2]); #>         } #>         ps[c1, c2] = log(Vc[c1]) + log(tau[c1, c2]) + sum(log_items); #>       } #>       tmp[c1] = log_sum_exp(ps[c1,]); #>     } #>     log_lik[j] = log_sum_exp(tmp); #>   } #>  #>   // latent class probabilities #>   for (j in 1:J) { #>     vector[C] tmp; #>     matrix[C, C] prob_joint; #>     for (c1 in 1:C) { #>       for (c2 in 1:C) { #>         array[l[j, 1]] real log_items; #>         for (m in 1:l[j, 1]) { #>           int i = ii[s[j, 1] + m - 1, 1]; #>           log_items[m] = y[s[j, 1] + m - 1, 1] * log(pi[i,c1]) + (1 - y[s[j, 1] + m - 1, 1]) * log(1 - pi[i,c1]) + y[s[j, 1] + m - 1, 2] * log(pi[i,c2]) + (1 - y[s[j, 1] + m - 1, 2]) * log(1 - pi[i,c2]); #>         } #>         prob_joint[c1, c2] = log(Vc[c1]) + log(tau[c1, c2]) + sum(log_items); #>       } #>     } #>     prob_transition_class[j] = exp(prob_joint) / sum(exp(prob_joint)); #>   } #>  #>   for (j in 1:J) { #>     for (a in 1:A) { #>       vector[C] prob_attr_class_t1; #>       vector[C] prob_attr_class_t2; #>       for (c in 1:C) { #>         prob_attr_class_t1[c] = sum(prob_transition_class[j,c,]) * Alpha[c,a]; #>         prob_attr_class_t2[c] = sum(prob_transition_class[j,,c]) * Alpha[c,a]; #>       } #>       prob_resp_attr[j,a,1] = sum(prob_attr_class_t1); #>       prob_resp_attr[j,a,2] = sum(prob_attr_class_t2); #>     } #>   } #> } #>"},{"path":"/reference/create_threaded_stan_tdcm.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating Multi-Threaded TDCM Stan Code — create_threaded_stan_tdcm","title":"Creating Multi-Threaded TDCM Stan Code — create_threaded_stan_tdcm","text":"Automating creation multi-threaded Stan code TDCM.","code":""},{"path":"/reference/create_threaded_stan_tdcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating Multi-Threaded TDCM Stan Code — create_threaded_stan_tdcm","text":"","code":"create_threaded_stan_tdcm(q_matrix)"},{"path":"/reference/create_threaded_stan_tdcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creating Multi-Threaded TDCM Stan Code — create_threaded_stan_tdcm","text":"q_matrix tibble containing assessment Q-matrix.","code":""},{"path":"/reference/create_threaded_stan_tdcm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating Multi-Threaded TDCM Stan Code — create_threaded_stan_tdcm","text":"`stan_code` list containing text Stan code blocks.","code":""},{"path":"/reference/create_threaded_stan_tdcm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creating Multi-Threaded TDCM Stan Code — create_threaded_stan_tdcm","text":"","code":"qmatrix = tibble::tibble(att_1 = c(1, 0, 1, 0, 1, 1),                          att_2 = c(0, 1, 0, 1, 1, 1)) create_threaded_stan_tdcm(q_matrix = qmatrix) #> $functions #> functions { #>   real minmax (real x) { #>     if (x < .01) { #>       return 0.01; #>     } #>  #>     if (x > 0.99) { #>       return 0.99; #>     } #>  #>     return x; #>   } #>  #>   vector sum_probs(vector beta, vector theta, array[] real xr, array[] int xi) { #>     int Z = num_elements(xi); #>     int ys = xi[Z - 1]; #>     int iis = xi[Z]; #>  #>     array[iis] int y1 = xi[1:iis]; #>     array[iis] int ii1 = xi[(iis + 1):(2 * iis)]; #>     array[iis] int jj1 = xi[((2 * iis) + 1):(3 * iis)]; #>     array[ys] int s1 = xi[((3 * iis) + 1):((3 * iis) + ys)]; #>     array[ys] int l1 = xi[((3 * iis) + ys + 1):((3 * iis) + (2 * ys))]; #>  #>     array[iis] int y2 = xi[((3 * iis) + (2 * ys) + 1):((4 * iis) + (2 * ys))]; #>     array[iis] int ii2 = xi[((4 * iis) + (2 * ys) + 1):((5 * iis) + (2 * ys))]; #>     array[iis] int jj2 = xi[((5 * iis) + (2 * ys) + 1):((6 * iis) + (2 * ys))]; #>     array[ys] int s2 = xi[((6 * iis) + (2 * ys) + 1):((6 * iis) + (3 * ys))]; #>     array[ys] int l2 = xi[((6 * iis) + (3 * ys) + 1):((6 * iis) + (4 * ys))]; #>  #>     int I = xi[Z - 7]; #>     int N = xi[Z - 6]; #>     int C = xi[Z - 5]; #>     int A = xi[Z - 4]; #>     int J = xi[Z - 3]; #>     int M = xi[Z - 2]; #>  #>     vector[C] Vc = beta[1:C]; #>     vector[I * C] pic = beta[(C + 1):(C + (I * C))]; #>     vector[C * C] tauc = beta[(C + (I * C) + 1):(C + (I * C) + (C * C))]; #>  #>     matrix[C, C] ps; #>     matrix[C, C] tau_c; #>     real person = 0; #>  #>     matrix[I, C] pi_c; #>     for(c in 1:C) { #>       for(i in 1:I) { #>         int ic = i + ((c-1) * I); #>         pi_c[i, c] = pic[ic]; #>       } #>     } #>  #>     for(c1 in 1:C) { #>       for(c2 in 1:C) { #>         int cc = c1 + ((c2 - 1) * C); #>         tau_c[c1, c2] = tauc[cc]; #>       } #>     } #>  #>     // Likelihood #>     for (j in 1:J) { #>       vector[C] tmp; #>       for (c1 in 1:C) { #>         for (c2 in 1:C) { #>           array[l1[j]] real log_items; #>           for (m in 1:l1[j]) { #>             int i = ii1[s1[j] + m - 1]; #>             log_items[m] = y1[s1[j] + m - 1] * log(pi_c[i,c1]) + (1 - y1[s1[j] + m - 1]) * log(1 - pi_c[i,c1]) + y2[s1[j] + m - 1] * log(pi_c[i,c2]) + (1 - y2[s1[j] + m - 1]) * log(1 - pi_c[i,c2]); #>           } #>           ps[c1, c2] = log(Vc[c1]) + log(tau_c[c1, c2]) + sum(log_items); #>         } #>         tmp[c1] = log_sum_exp(ps[c1,]); #>       } #>       person += log_sum_exp(tmp); #>     } #>  #>     return [person]'; #>   } #>  #>   vector person_loglik(vector beta, vector theta, array[] real xr, array[] int xi) { #>     int Z = num_elements(xi); #>     int ys = xi[Z - 1]; #>     int iis = xi[Z]; #>  #>     array[iis] int y1 = xi[1:iis]; #>     array[iis] int ii1 = xi[(iis + 1):(2 * iis)]; #>     array[iis] int jj1 = xi[((2 * iis) + 1):(3 * iis)]; #>     array[ys] int s1 = xi[((3 * iis) + 1):((3 * iis) + ys)]; #>     array[ys] int l1 = xi[((3 * iis) + ys + 1):((3 * iis) + (2 * ys))]; #>  #>     array[iis] int y2 = xi[((3 * iis) + (2 * ys) + 1):((4 * iis) + (2 * ys))]; #>     array[iis] int ii2 = xi[((4 * iis) + (2 * ys) + 1):((5 * iis) + (2 * ys))]; #>     array[iis] int jj2 = xi[((5 * iis) + (2 * ys) + 1):((6 * iis) + (2 * ys))]; #>     array[ys] int s2 = xi[((6 * iis) + (2 * ys) + 1):((6 * iis) + (3 * ys))]; #>     array[ys] int l2 = xi[((6 * iis) + (3 * ys) + 1):((6 * iis) + (4 * ys))]; #>  #>     int I = xi[Z - 7]; #>     int N = xi[Z - 6]; #>     int C = xi[Z - 5]; #>     int A = xi[Z - 4]; #>     int J = xi[Z - 3]; #>     int M = xi[Z - 2]; #>  #>     vector[C] Vc = beta[1:C]; #>     vector[I * C] pic = beta[(C + 1):(C + (I * C))]; #>     vector[C * C] tauc = beta[(C + (I * C) + 1):(C + (I * C) + (C * C))]; #>  #>     matrix[C, C] ps; #>     matrix[C, C] tau_c; #>     vector[J] person; #>  #>     matrix[I, C] pi_c; #>     for(c in 1:C) { #>       for(i in 1:I) { #>         int ic = i + ((c-1) * I); #>         pi_c[i, c] = pic[ic]; #>       } #>     } #>  #>     for(c1 in 1:C) { #>       for(c2 in 1:C) { #>         int cc = c1 + ((c2 - 1) * C); #>         tau_c[c1, c2] = tauc[cc]; #>       } #>     } #>  #>     // Likelihood #>     for (j in 1:J) { #>       vector[C] tmp; #>       for (c1 in 1:C) { #>         for (c2 in 1:C) { #>           array[l1[j]] real log_items; #>           for (m in 1:l1[j]) { #>             int i = ii1[s1[j] + m - 1]; #>             log_items[m] = y1[s1[j] + m - 1] * log(pi_c[i,c1]) + (1 - y1[s1[j] + m - 1]) * log(1 - pi_c[i,c1]) + y2[s1[j] + m - 1] * log(pi_c[i,c2]) + (1 - y2[s1[j] + m - 1]) * log(1 - pi_c[i,c2]); #>           } #>           ps[c1, c2] = log(Vc[c1]) + log(tau_c[c1, c2]) + sum(log_items); #>         } #>         tmp[c1] = log_sum_exp(ps[c1,]); #>       } #>       person[j] = log_sum_exp(tmp); #>     } #>  #>     return person; #>   } #>  #>   vector resp_transition(vector beta, vector theta, array[] real xr, array[] int xi) { #>     int Z = num_elements(xi); #>     int ys = xi[Z - 1]; #>     int iis = xi[Z]; #>  #>     array[iis] int y1 = xi[1:iis]; #>     array[iis] int ii1 = xi[(iis + 1):(2 * iis)]; #>     array[iis] int jj1 = xi[((2 * iis) + 1):(3 * iis)]; #>     array[ys] int s1 = xi[((3 * iis) + 1):((3 * iis) + ys)]; #>     array[ys] int l1 = xi[((3 * iis) + ys + 1):((3 * iis) + (2 * ys))]; #>  #>     array[iis] int y2 = xi[((3 * iis) + (2 * ys) + 1):((4 * iis) + (2 * ys))]; #>     array[iis] int ii2 = xi[((4 * iis) + (2 * ys) + 1):((5 * iis) + (2 * ys))]; #>     array[iis] int jj2 = xi[((5 * iis) + (2 * ys) + 1):((6 * iis) + (2 * ys))]; #>     array[ys] int s2 = xi[((6 * iis) + (2 * ys) + 1):((6 * iis) + (3 * ys))]; #>     array[ys] int l2 = xi[((6 * iis) + (3 * ys) + 1):((6 * iis) + (4 * ys))]; #>  #>     int I = xi[Z - 7]; #>     int N = xi[Z - 6]; #>     int C = xi[Z - 5]; #>     int A = xi[Z - 4]; #>     int J = xi[Z - 3]; #>     int M = xi[Z - 2]; #>  #>     vector[C] Vc = beta[1:C]; #>     vector[I * C] pic = beta[(C + 1):(C + (I * C))]; #>     vector[C * C] tauc = beta[(C + (I * C) + 1):(C + (I * C) + (C * C))]; #>  #>     matrix[C, C] ps; #>     matrix[C, C] tau_c; #>     array[J] matrix[C, C] prob_transition_class; #>  #>     vector[J * C * C] person; #>  #>     matrix[I, C] pi_c; #>     for(c in 1:C) { #>       for(i in 1:I) { #>         int ic = i + ((c-1) * I); #>         pi_c[i, c] = pic[ic]; #>       } #>     } #>  #>     for(c1 in 1:C) { #>       for(c2 in 1:C) { #>         int cc = c1 + ((c2 - 1) * C); #>         tau_c[c1, c2] = tauc[cc]; #>       } #>     } #>  #>     // latent class probabilities #>     for (j in 1:J) { #>       vector[C] tmp; #>       matrix[C, C] prob_joint; #>       for (c1 in 1:C) { #>         for (c2 in 1:C) { #>           array[l1[j]] real log_items; #>           for (m in 1:l1[j]) { #>             int i = ii1[s1[j] + m - 1]; #>             log_items[m] = y1[s1[j] + m - 1] * log(pi_c[i,c1]) + (1 - y1[s1[j] + m - 1]) * log(1 - pi_c[i,c1]) + y2[s1[j] + m - 1] * log(pi_c[i,c2]) + (1 - y2[s1[j] + m - 1]) * log(1 - pi_c[i,c2]); #>           } #>           prob_joint[c1, c2] = log(Vc[c1]) + log(tau_c[c1, c2]) + sum(log_items); #>         } #>       } #>       prob_transition_class[j] = exp(prob_joint) / sum(exp(prob_joint)); #>  #>       for (c1 in 1:C) { #>         for (c2 in 1:C) { #>           person[((c1 - 1) * 8) + c2 + ((j - 1) * C * C)] = prob_transition_class[j,c1,c2]; #>         } #>       } #>     } #>     return person; #>   } #> } #>  #> $data #> data { #>   int<lower=1> I; #>   int<lower=1> J; #>   int<lower=1> N; #>   int<lower=1> C; #>   int<lower=1> A; #>   array[N, 2] int<lower=1,upper=I> ii; #>   array[N, 2] int<lower=1,upper=J> jj; #>   array[N, 2] int<lower=0,upper=1> y; #>   array[J, 2] int<lower=1,upper=N> s; #>   array[J, 2] int<lower=1,upper=I> l; #>   matrix[C,A] Alpha; #>   int<lower=1> n_shards; #> } #>  #> $transformed_data #> transformed data { #>   int ys = num_elements(s) / 2 / n_shards; #>   int iis = num_elements(ii) / 2 / n_shards; #>  #>   int M = iis; #>  #>   array[n_shards, (4 * ys) + (6 * iis) + 8] int xi; #>  #>   // an empty set of per-shard parameters #>   array[n_shards] vector[0] theta; #>  #>   array[n_shards,1] real xr; #>   for(kk in 1:n_shards) { #>     xr[kk, 1] = 1.0; #>   } #>  #>   // split into shards #>   for (i in 1:n_shards) { #>     int ylower; #>     int yupper; #>     int iilower; #>     int iiupper; #>  #>     ylower = ((i - 1) * ys) + 1; #>     yupper = i * ys; #>     iilower = ((i - 1) * iis) + 1; #>     iiupper = i * iis; #>  #>     xi[i, 1:iis] = y[iilower:iiupper, 1]; #>     xi[i, (iis + 1):(iis + iis)] = ii[iilower:iiupper, 1]; #>     xi[i, ((2 * iis) + 1):((2 * iis) + iis)] = jj[iilower:iiupper, 1]; #>     xi[i, ((3 * iis) + 1):((3 * iis) + ys)] = s[1:ys, 1]; #>     xi[i, ((3 * iis) + ys + 1):((3 * iis) + (2 * ys))] = l[ylower:yupper, 1]; #>     xi[i, ((3 * iis) + (2 * ys) + 1):((4 * iis) + (2 * ys))] = y[iilower:iiupper, 2]; #>     xi[i, ((4 * iis) + (2 * ys) + 1):((5 * iis) + (2 * ys))] = ii[iilower:iiupper, 2]; #>     xi[i, ((5 * iis) + (2 * ys) + 1):((6 * iis) + (2 * ys))] = jj[iilower:iiupper, 2]; #>     xi[i, ((6 * iis) + (2 * ys) + 1):((6 * iis) + (3 * ys))] = s[1:ys, 2]; #>     xi[i, ((6 * iis) + (3 * ys) + 1):((6 * iis) + (4 * ys))] = l[ylower:yupper, 2]; #>     xi[i, ((6 * iis) + (4 * ys) + 1)] = I; #>     xi[i, ((6 * iis) + (4 * ys) + 2)] = N / n_shards; #>     xi[i, ((6 * iis) + (4 * ys) + 3)] = C; #>     xi[i, ((6 * iis) + (4 * ys) + 4)] = A; #>     xi[i, ((6 * iis) + (4 * ys) + 5)] = J / n_shards; #>     xi[i, ((6 * iis) + (4 * ys) + 6)] = iis; #>     xi[i, ((6 * iis) + (4 * ys) + 7)] = ys; #>     xi[i, ((6 * iis) + (4 * ys) + 8)] = iis; #>   } #> } #>  #> $parameters #> parameters { #>   array[C] simplex[C] tau; #>   simplex[C] Vc; #>   real l1_0; #>   real l2_0; #>   real l3_0; #>   real l4_0; #>   real l5_0; #>   real l6_0; #>   real<lower=0> l1_11; #>   real<lower=0> l2_12; #>   real<lower=0> l3_11; #>   real<lower=0> l4_12; #>   real<lower=0> l5_11; #>   real<lower=0> l5_12; #>   real<lower=0> l6_11; #>   real<lower=0> l6_12; #>   real<lower=-1 * fmin(l5_11, l5_12)> l5_212; #>   real<lower=-1 * fmin(l6_11, l6_12)> l6_212; #> } #>  #> $transformed_parameters #> transformed parameters { #>   matrix[I,C] pi; #>  #>   pi[1,1] = inv_logit(l1_0); #>   pi[2,1] = inv_logit(l2_0); #>   pi[3,1] = inv_logit(l3_0); #>   pi[4,1] = inv_logit(l4_0); #>   pi[5,1] = inv_logit(l5_0); #>   pi[6,1] = inv_logit(l6_0); #>   pi[1,2] = inv_logit(l1_0+l1_11); #>   pi[2,2] = inv_logit(l2_0); #>   pi[3,2] = inv_logit(l3_0+l3_11); #>   pi[4,2] = inv_logit(l4_0); #>   pi[5,2] = inv_logit(l5_0+l5_11); #>   pi[6,2] = inv_logit(l6_0+l6_11); #>   pi[1,3] = inv_logit(l1_0); #>   pi[2,3] = inv_logit(l2_0+l2_12); #>   pi[3,3] = inv_logit(l3_0); #>   pi[4,3] = inv_logit(l4_0+l4_12); #>   pi[5,3] = inv_logit(l5_0+l5_12); #>   pi[6,3] = inv_logit(l6_0+l6_12); #>   pi[1,4] = inv_logit(l1_0+l1_11); #>   pi[2,4] = inv_logit(l2_0+l2_12); #>   pi[3,4] = inv_logit(l3_0+l3_11); #>   pi[4,4] = inv_logit(l4_0+l4_12); #>   pi[5,4] = inv_logit(l5_0+l5_11+l5_12+l5_212); #>   pi[6,4] = inv_logit(l6_0+l6_11+l6_12+l6_212); #>  #>   array[I * C] real pic; #>   for(c in 1:C) { #>     for(i in 1:I) { #>       int ic = i + ((c - 1) * I); #>       pic[ic] = pi[i, c]; #>     } #>   } #>  #>   array[C * C] real tauc; #>   for(c1 in 1:C) { #>     for(c2 in 1:C) { #>       int cc = c2 + ((c1 - 1) * C); #>       tauc[cc] = tau[c2, c1]; #>     } #>   } #>  #>   // a set of shared parameters #>   vector[C + (I * C) + (C * C)] beta; #>   beta[1:C] = Vc[1:C]; #>   beta[(C + 1):(C + (I * C))] = to_vector(pic[1:(I * C)]); #>   beta[(C + (I * C) + 1):(C + (I * C) + (C * C))] = to_vector(tauc[1:(C * C)]); #> } #>  #> $model #> model { #>   array[C, C] real ps; #>  #>   // Priors #>   l1_0 ~ normal(0, 2); #>   l2_0 ~ normal(0, 2); #>   l3_0 ~ normal(0, 2); #>   l4_0 ~ normal(0, 2); #>   l5_0 ~ normal(0, 2); #>   l6_0 ~ normal(0, 2); #>   l1_11 ~ lognormal(0, 1); #>   l2_12 ~ lognormal(0, 1); #>   l3_11 ~ lognormal(0, 1); #>   l4_12 ~ lognormal(0, 1); #>   l5_11 ~ lognormal(0, 1); #>   l5_12 ~ lognormal(0, 1); #>   l6_11 ~ lognormal(0, 1); #>   l6_12 ~ lognormal(0, 1); #>   l5_212 ~ normal(0, 2); #>   l6_212 ~ normal(0, 2); #>  #>   target += sum(map_rect(sum_probs, beta, theta, xr, xi)); #> } #>  #> $generated_quantities #> generated quantities { #>   vector[J] log_lik; #>   array[J] matrix[C, C] format_prob_transition_class; #>   vector[J*C*C] prob_transition_class; #>   array[J] matrix[A, 2] prob_resp_attr; #>  #>   log_lik = map_rect(person_loglik, beta, theta, xr, xi); #>  #>   prob_transition_class = map_rect(resp_transition, beta, theta, xr, xi); #>  #>   for (j in 1:J) { #>     for (c1 in 1:C) { #>       for (c2 in 1:C) { #>         int iter = ((c1 - 1) * 8) + c2 + ((j - 1) * C * C); #>         format_prob_transition_class[j,c1,c2] = prob_transition_class[iter]; #>       } #>     } #>   } #>  #>   for (j in 1:J) { #>     for (a in 1:A) { #>       vector[C] prob_attr_class_t1; #>       vector[C] prob_attr_class_t2; #>       for (c in 1:C) { #>         prob_attr_class_t1[c] = sum(format_prob_transition_class[j,c,]) * Alpha[c,a]; #>         prob_attr_class_t2[c] = sum(format_prob_transition_class[j,,c]) * Alpha[c,a]; #>       } #>       prob_resp_attr[j,a,1] = sum(prob_attr_class_t1); #>       prob_resp_attr[j,a,2] = sum(prob_attr_class_t2); #>     } #>   } #> } #>"},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See `magrittr::[%>%][magrittr::%>%]` details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"return value, called import pipe operator magrittr","code":""},{"path":"/reference/shard_calculator.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the Number of Shards and Simultaneous Chains — shard_calculator","title":"Calculate the Number of Shards and Simultaneous Chains — shard_calculator","text":"Calculating number shards simultaneous chains.","code":""},{"path":"/reference/shard_calculator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the Number of Shards and Simultaneous Chains — shard_calculator","text":"","code":"shard_calculator(num_respondents, num_responses, num_chains)"},{"path":"/reference/shard_calculator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the Number of Shards and Simultaneous Chains — shard_calculator","text":"num_respondents integer specifying number respondents. num_responses integer specifying number responses (.e., total number items completed across respondents). num_chains integer specifying number chains need run.","code":""},{"path":"/reference/shard_calculator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the Number of Shards and Simultaneous Chains — shard_calculator","text":"`ret` list containing number shards use within chain number chains run parallel.","code":""},{"path":"/reference/shard_calculator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the Number of Shards and Simultaneous Chains — shard_calculator","text":"","code":"shard_calculator(num_respondents = 1000, num_responses = 5000,                  num_chains = 4) #> $n_shards_to_use #> [1] 1 #>  #> $parallel_chains #> [1] 3 #>"},{"path":"/reference/tidyeval.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy eval helpers — tidyeval","title":"Tidy eval helpers — tidyeval","text":"page lists tidy eval tools reexported package rlang. learn using tidy eval scripts packages high level, see dplyr programming vignette ggplot2 packages vignette. Metaprogramming section Advanced R may also useful deeper dive. tidy eval operators {{, !!, !!! syntactic constructs specially interpreted tidy eval functions. mostly need {{, !! !!! advanced operators use simple cases. curly-curly operator {{ allows tunnel data-variables passed function arguments inside tidy eval functions. {{ designed individual arguments. pass multiple arguments contained dots, use ... normal way.   enquo() enquos() delay execution one several function arguments. former returns single expression, latter returns list expressions. defused, expressions longer evaluate . must injected back evaluation context !! (single expression) !!! (list expressions).   simple case, code equivalent usage {{ ... . Defusing enquo() enquos() needed complex cases, instance need inspect modify expressions way. .data pronoun object represents current slice data. variable name string, use .data pronoun subset variable [[.   Another tidy eval operator :=. makes possible use glue curly-curly syntax LHS =. technical reasons, R language support complex expressions left =, use := workaround.   Many tidy eval functions like dplyr::mutate() dplyr::summarise() give automatic name unnamed inputs. need create sort automatic names , use as_label(). instance, glue-tunnelling syntax can reproduced manually :   Expressions defused enquo() (tunnelled {{) need simple column names, can arbitrarily complex. as_label() handles cases gracefully. code assumes simple column name, use as_name() instead. safer throws error input name expected.","code":"my_function <- function(data, var, ...) {   data %>%     group_by(...) %>%     summarise(mean = mean({{ var }})) } my_function <- function(data, var, ...) {   # Defuse   var <- enquo(var)   dots <- enquos(...)    # Inject   data %>%     group_by(!!!dots) %>%     summarise(mean = mean(!!var)) } my_var <- \"disp\" mtcars %>% summarise(mean = mean(.data[[my_var]])) my_function <- function(data, var, suffix = \"foo\") {   # Use `{{` to tunnel function arguments and the usual glue   # operator `{` to interpolate plain strings.   data %>%     summarise(\"{{ var }}_mean_{suffix}\" := mean({{ var }})) } my_function <- function(data, var, suffix = \"foo\") {   var <- enquo(var)   prefix <- as_label(var)   data %>%     summarise(\"{prefix}_mean_{suffix}\" := mean(!!var)) }"},{"path":"/reference/tidyeval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tidy eval helpers — tidyeval","text":"return value, called reexport tools package rlang","code":""},{"path":[]},{"path":"/news/index.html","id":"tdcmstan-300","dir":"Changelog","previous_headings":"","what":"tdcmStan 3.0.0","title":"tdcmStan 3.0.0","text":"CRAN release: 2024-03-28 package functions updated work new Stan syntax. Added pre-compiled Stan scripts receive updates future Stan syntax changes.","code":""},{"path":"/news/index.html","id":"tdcmstan-200","dir":"Changelog","previous_headings":"","what":"tdcmStan 2.0.0","title":"tdcmStan 2.0.0","text":"CRAN release: 2023-03-03 function parameters simplified user friendly. new function create_fng_no_common_item_tdcm() created create Stan code fungible TDCMs use different items time 1 time 2. Added NEWS.md file track changes package.","code":""}]
